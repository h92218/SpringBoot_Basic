* ApplicationContext
- BeanFactory(스프링 컨테이너 최상위 인터페이스)의 기능을 상속받는다.
- 빈 관리기능 + 편리한 부가기능 제공
- 아래와 같은 부가기능이 있음
    - MessageSource 기능 제공 : 국가에 맞는 언어로 출력
    - 환경변수 : 환경별로 정보처리 기능 제공
    - 애플리케이션 이벤트 : 이벤트를 발행하고 구독하는 모델 지원
    - 리소스 조회 : 파일,클래스패스,외부 등에서 리소스를 편리하게 조회
- SpringApplication.run 실행시 ApplicationContext가 생성된다.

* 스프링 컨테이너는 다양한 형식의 설정정보 사용 가능
- AppConfig.class ( 어노테이션 기반)
- appConfig.xml (컴파일 없이 변경 가능함)

* AppConfig
-> 객체를 생성하고 의존관계를 연결해 줌
-> 사용영역과 구성영역의 분리를 가능케 함 (SRP 단일책임의 원칙)
-> 구현체는 인터페이스에만 의존할수 있게 함 (DIP 의존관계 역전 원칙)
-> 구현체 입장에서는 생성자를 통해 어떤 객체가 주입될지 모르며, 외부에서 결정되는 것임.
-> AppConfig는 구성영역, 클라이언트는 사용영역이 되며, 소프트웨어 요소를 새롭게 확장해도 클라이언트 코드를 변경할 필요가 없음(OCP원칙)

* 제어의 역전 (Inversion of Control)
-> 외부 구성영역(ex.AppConfig)이 프로그램의 제어 흐름을 가짐
-> 구현객체는 어떤게 호출될지 모름, 자신의 로직만 실행
-> 프레임워크를 사용하면 프레임워크의 라이프 사이클 내에서 본인이 작성한 코드가 제어되고 실행된다. 이것이 제어의 역전
-> 예를 들면 어노테이션을 붙이면 스프링 컨테이너는 해당 객체를 관리하고 필요한 곳에 주입함.(DI는 제어의 역전 방법 중 하나)


* DI (Dependency Injection)
-> 의존관계 주입, 의존성 주입이라고 함
-> 애플리케이션 런타임에 외부에서 구현객체를 생성하고 클라이언트에 전달하여 의존관계가 연결되는 것
-> 정적인 클래스 의존관계를 변경하지 않고 동적인 객체인스턴스 의존관계를 쉽게 변경할 수 있다. 즉 애플리케이션 코드의 변경이 필요없다. 

* 스프링 빈 설정 메타 정보 - BeanDefinition
- @Bean, <bean> 사용하면 메타정보가 생성됨
- 스프링컨테이너는 이 메타정보를 기반으로 빈을 생성함

